# -*- coding: utf-8 -*-
"""Git_Pnemonia_Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aNYSRs1E2rlupENluBLKId763hAdl_Am
"""

# Unzip the file
!unzip chest-xray-pneumonia.zip

# Commented out IPython magic to ensure Python compatibility.
# Import All Nesessary Libraries
import os, random, gc, math, time
import numpy as np
import pandas as pd

import cv2
from PIL import Image

import matplotlib.pyplot as plt
import seaborn as sns


import tensorflow as tf
import keras_preprocessing.image
import keras.backend as k
from keras.applications import VGG16, VGG19
from keras.models import Model
from keras.optimizers import SGD, Adam
from keras.layers import BatchNormalization, Dense, Dropout, Flatten
from keras.layers import GlobalAveragePooling2D, MaxPooling2D, LeakyReLU
from keras.layers import Input, AvgPool2D, Conv2D
from keras.layers import multiply, concatenate, Lambda, Reshape
from keras import backend as K
from keras.callbacks import ModelCheckpoint, EarlyStopping
from keras.callbacks import ReduceLROnPlateau
from keras.preprocessing.image import ImageDataGenerator
from tensorflow import metrics
from keras.utils.vis_utils import plot_model


from sklearn.metrics import classification_report, accuracy_score
from sklearn.metrics import confusion_matrix, roc_auc_score
from sklearn.utils import class_weight


# Configuration
# %matplotlib inline

# Specifying the Training Parameters

is_pretrained = True
keep_training = True # Adam -> SGD
batch_size = 39
width = 150
height = 150
learning_rate = 1e-4
batch_size = 64
epochs = 10

def dir_file_count(directory):
  total_files = 0
  for root, dirs, files in os.walk(".", topdown=False):
    total_files += len(list(filter(lambda x: x.endswith('.jpeg'), files)))
  return total_files

def xray_process(im):
  # X-Rays are negative images. Imagenet was trained on normal images.
  im = 255. - im

  # Imagenet tensorflow samples are scaled between -1 (black) and 1 (white)
  # https://github.com/keras-team/keras-applications/blob/master/keras_applications/imagenet_utils.py
  im /= 255.
  im -= .5
  im *= 2.
  return im

# Defining Paths

target_size = (height, width)
class_mode = 'categorical'
training_dir = 'chest_xray/train'
testing_dir = 'chest_xray/test'
proj_dir = 'temp'
# Creating Directories to Store Models
!mkdir temp/
!mkdir temp/models
!mkdir images

# TrainSet Preparation
train_datagen = ImageDataGenerator(rotation_range=20,
                                   width_shift_range=0.15,
                                   height_shift_range=0.15,
                                   shear_range=0.15,
                                   zoom_range=0.15,
                                   horizontal_flip=True,
                                   fill_mode='nearest',
                                   preprocessing_function=xray_process)

train_generator = train_datagen.flow_from_directory(training_dir,
                                                    target_size=target_size,
                                                    interpolation='lanczos',
                                                    class_mode=class_mode,
                                                    batch_size=batch_size,
                                                    shuffle=True)

# TestSet Preparation
test_datagen = ImageDataGenerator(
                                  fill_mode='nearest',
                                  preprocessing_function=xray_process)

test_generator = test_datagen.flow_from_directory(testing_dir,
                                                  target_size=target_size,
                                                  interpolation='lanczos',
                                                  class_mode=class_mode,
                                                  batch_size=batch_size,
                                                  shuffle=False)

def get_weight(y):
    class_weight_current = class_weight.compute_class_weight('balanced',
                                                             np.unique(y), y)
    return class_weight_current

class_w = get_weight(train_generator.classes)
print(class_w)

def get_image_set(image_set, image_type):
  def get_image_path(path_pre, image_name):
    return '{}/{}/{}/{}'.format(path_pre, image_set, image_type, image_name)

  path_pre = './chest_xray'
  image_list = os.listdir('{}/{}/{}'.format(path_pre, image_set, image_type))
  image_list = list(map(lambda x: get_image_path(path_pre, x), image_list))

  # Ignore .DS_Store files
  image_list = list(filter(lambda x: x.endswith('.jpeg'), image_list))
  return image_list

tr_normal = get_image_set('train', 'NORMAL')
tr_pneumonia = get_image_set('train', 'PNEUMONIA')

te_normal = get_image_set('test', 'NORMAL')
te_pneumonia = get_image_set('test', 'PNEUMONIA')

images_normal = tr_normal + te_normal
images_pneumonia = tr_pneumonia + te_pneumonia
images_pneumonia_bacterial = [img for img in images_pneumonia
                              if img.split('/')[-1].split('_')[1] == 'bacteria']
images_pneumonia_viral = [img for img in images_pneumonia
                          if img.split('/')[-1].split('_')[1] == 'virus']

images_full = images_normal + images_pneumonia
images_test = te_normal + te_pneumonia

# Plotting the count of Patient Types
sns.set_style('whitegrid')
sns.barplot(x=['Normal', 'Pneumonia'],
            y=[len(images_normal),
               len(images_pneumonia)])

# Plotting the type of Dieseases
sns.set_style('whitegrid')
sns.barplot(x=['Bacterial', 'Viral'],
            y=[len(images_pneumonia_bacterial),
               len(images_pneumonia_viral)])

def get_image(path):
  return cv2.imread(path, 0)

def get_resized_image(path, width, height):
  im = Image.fromarray(get_image(path))
  im_w, im_h = im.size

  # Proportionally scale to be contained within canvas bounds.
  if im_w > width:
    im_h = int(width/im_w * im_h)
    im_w = width
  if im_h > height:
    im_w = int(height/im_h * im_w)
    im_h = height

  if [im_w, im_h] != list(im.size):
    im.thumbnail((im_w, im_h), Image.ANTIALIAS)

  # Return the image over a black background.    
  im_resized = Image.new('RGB', (width, height), (0, 0, 0))
  offset = ((width - im.size[0]) // 2,
            (height - im.size[1]) // 2)
  im_resized.paste(im, offset)

  return np.array(im_resized)

def plot_sample_xrays(image_set, image_label,
                      width=width//2, height=height//2,
                      rows=1, cols=3,
                      size_w=4, size_h=3):
  f,ax = plt.subplots(rows, cols, figsize=(cols*size_w, rows*size_h))

  for idx in range(rows*cols):
    i = random.randint(0, len(image_set))
    im = get_resized_image(image_set[i], width, height)[:, :, 0]
    ax[idx%cols].imshow(im, cmap='bone')
    ax[idx%cols].axis('off')
    ax[idx%cols].set_title('Diagnosis: {}'.format(image_label))
  plt.show()

# Plotting Sample Images
plot_sample_xrays(images_normal, 'Normal')
plot_sample_xrays(images_pneumonia_bacterial, 'Bacterial Pneumonia')
plot_sample_xrays(images_pneumonia_viral, 'Viral Pneumonia')

#BASE MODEL 1
common_input = Input(shape=(height, width, 3))

# create the base pre-trained model
base_model_1 = VGG19(weights='imagenet',
                       include_top=False,
                       input_shape=(height, width, 3))

base_model_1.summary()

# ASdding Custom Layers to the Pred-Build Network 
x1 = base_model_1.output
x1 = Dropout(0.5)(x1)
x1 = GlobalAveragePooling2D()(x1)
x1 = Dense(128, activation='relu')(x1)
x1 = BatchNormalization()(x1)
predictions = Dense(2, activation='sigmoid')(x1)

for layer in base_model_1.layers:
    layer.trainable = False

  
model_1 = Model(inputs=base_model_1.input, outputs=predictions)
model_1.compile(optimizer=Adam(lr=learning_rate),loss='categorical_crossentropy',metrics=['accuracy'])

# Creates directory, if directory exists removes if remove parameter is True
def create_directory(directory_path, remove=False):
  if remove and os.path.exists(directory_path):
    try:
      shutil.rmtree(directory_path)
      os.mkdir(directory_path)
    except:
      print("Could not remove directory : ", directory_path)
      return False
  else:
    try:
      os.mkdir(directory_path)
    except:
      print("Could not create directory: ", directory_path)
      return False   
  return True

main_model_dir = '{}/models'.format(proj_dir)
m_dir = main_model_dir + '/' + time.strftime('%Y-%m-%d_%H-%M-%S') + '/'
ckp_path = m_dir + 'MODEL_ACC-{val_acc:.2f}-MODEL_LOSS-{val_loss:.2f}.hdf5'
create_directory(m_dir, remove=True)

# Early Stopping Parameters
checkpoint = ModelCheckpoint(ckp_path,
                             monitor='val_acc', 
                             save_weights_only=True,
                             save_best_only=True)
reduce_lr = ReduceLROnPlateau(monitor='val_loss',
                              patience=3,
                              cooldown=2,
                              min_lr=1e-12,
                              verbose=1)
early_stopping = EarlyStopping(monitor='val_acc',
                               mode='max',
                               patience=11,
                               verbose=1,
                               restore_best_weights=True)
callbacks = [checkpoint, reduce_lr, early_stopping]

# Fitting the model to the Data
hist = model_1.fit_generator(train_generator,
                             steps_per_epoch=len(train_generator),
                             epochs=20,
                             verbose=1,
                             callbacks=callbacks,
                             validation_data=test_generator,
                             validation_steps=len(test_generator),
                             class_weight=class_w)

model_1.summary()

# Saving Model Graph

plot_model(model_1, to_file='images/Generator_model_plot.png', show_shapes=True, show_layer_names=True)

# Training Accuracy
plt.plot(hist.history['acc'])
plt.plot(hist.history['val_acc'])
plt.title('model accuracy')
plt.ylabel('Accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'validate'], loc='best')
plt.show()

# Diffrent Evaluation Metrics
vl_score = model_1.predict_generator(test_generator)

classes = ['Normal', 'Pneumonia']
print(classification_report(test_generator.classes,
                            np.argmax(vl_score, axis=1),
                            target_names=classes))
print('AUC: ', roc_auc_score(test_generator.classes,
                             np.argmax(vl_score, axis=1)))

# plotting Confussion Accuracy
acc = accuracy_score(test_generator.classes, np.argmax(vl_score, axis=1))*100.0
cm = confusion_matrix(test_generator.classes, np.argmax(vl_score, axis=1))
cm_df = pd.DataFrame(cm, index=classes, columns=classes)

plt.figure(figsize=(12,8))
sns.heatmap(cm_df, annot=True, cmap='Blues', fmt='g')
plt.title('Pneumonia Detection Accuracy: {0:.1f}%'.format(acc))
plt.ylabel('True Label')
plt.xlabel('Predicted Label')
plt.show()

"""# Refrences:

Based on https://github.com/deadskull7/Pneumonia-Diagnosis-using-XRays-96-percent-Recall

Based on https://github.com/iRyanBell/chest_xray_pneumonia_vgg_attn_ensemble
"""